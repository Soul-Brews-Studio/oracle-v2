<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KlakMath Vibes - Gesture Control</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      background: #0a0a0f;
      font-family: 'Courier New', monospace;
    }
    canvas { display: block; }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      z-index: 100;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      max-width: 280px;
    }

    h1 {
      font-size: 1.4rem;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #ff6b9d, #c44dff, #6b9dff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .info {
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 12px;
    }

    .gesture-status {
      background: rgba(196, 77, 255, 0.2);
      border: 1px solid #c44dff;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
      text-align: center;
    }

    .gesture-icon {
      font-size: 2rem;
      display: block;
      margin-bottom: 5px;
    }

    .gesture-name {
      font-size: 0.9rem;
      color: #c44dff;
      font-weight: bold;
    }

    .gesture-hint {
      font-size: 0.65rem;
      color: #888;
      margin-top: 5px;
    }

    .control {
      margin: 8px 0;
    }

    label {
      display: block;
      font-size: 0.7rem;
      color: #aaa;
      margin-bottom: 4px;
    }

    input[type="range"] {
      width: 100%;
      accent-color: #c44dff;
    }

    .value {
      font-size: 0.65rem;
      color: #c44dff;
    }

    button {
      background: linear-gradient(90deg, #ff6b9d, #c44dff);
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      color: white;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8rem;
      margin-top: 8px;
      margin-right: 5px;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(196, 77, 255, 0.5);
    }

    button.active {
      box-shadow: 0 0 30px rgba(196, 77, 255, 0.8);
    }

    #fps {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #666;
      font-size: 0.7rem;
    }

    #video-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 240px;
      height: 180px;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(196, 77, 255, 0.5);
      box-shadow: 0 0 30px rgba(196, 77, 255, 0.3);
      z-index: 100;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    #hand-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }

    .gesture-guide {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 12px;
      color: #888;
      font-size: 0.7rem;
      z-index: 100;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .gesture-guide h3 {
      color: #c44dff;
      margin-bottom: 8px;
      font-size: 0.8rem;
    }

    .gesture-guide div {
      margin: 4px 0;
    }

    .gesture-guide span {
      color: #fff;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .pulse {
      animation: pulse 0.5s ease-in-out;
    }

    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    .rainbow-mode {
      animation: rainbow 2s linear infinite;
    }

    .camera-off {
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.9);
      color: #666;
      font-size: 0.8rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>KlakMath + Gestures</h1>
    <div class="info">Move your hands to control!</div>

    <div class="gesture-status">
      <span class="gesture-icon" id="gestureIcon">üëã</span>
      <div class="gesture-name" id="gestureName">Waiting for camera...</div>
      <div class="gesture-hint" id="gestureHint">Click "Start Camera" below</div>
    </div>

    <div class="control">
      <label>Tween Speed (CdsTween)</label>
      <input type="range" id="tweenSpeed" min="1" max="20" value="8">
      <span class="value" id="tweenSpeedVal">8</span>
    </div>

    <div class="control">
      <label>Noise Scale</label>
      <input type="range" id="noiseScale" min="0.1" max="3" step="0.1" value="1">
      <span class="value" id="noiseScaleVal">1.0</span>
    </div>

    <div class="control">
      <label>Particle Count</label>
      <input type="range" id="particleCount" min="500" max="10000" step="500" value="3000">
      <span class="value" id="particleCountVal">3000</span>
    </div>

    <button id="startCamera">üì∑ Start Camera</button>
    <button id="stopCamera" style="display:none;">‚èπÔ∏è Stop Camera</button>
    <button id="randomize">üé≤ Randomize</button>
    <button id="explode">üí• Explode!</button>
  </div>

  <div id="fps">FPS: 60</div>

  <div id="video-container" class="camera-off">
    <div>Click "Start Camera"<br>to enable gestures</div>
    <video id="video" playsinline></video>
    <canvas id="hand-canvas"></canvas>
  </div>

  <div class="gesture-guide">
    <h3>Gesture Controls</h3>
    <div>‚úä <span>Fist</span> ‚Üí Freeze particles</div>
    <div>üñêÔ∏è <span>Open Palm</span> ‚Üí Zoom control</div>
    <div>ü§è <span>Pinch</span> ‚Üí Scale particles</div>
    <div>üëÜ <span>Point</span> ‚Üí EXPLODE!</div>
    <div>‚úåÔ∏è <span>Peace</span> ‚Üí Rainbow mode</div>
    <div>üñêÔ∏è <span>Move Hand</span> ‚Üí Rotate scene</div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ============================================
    // KlakMath Implementations in JavaScript
    // ============================================

    class XXHash {
      constructor(seed = 0) {
        this.seed = seed >>> 0;
      }

      static PRIME32_1 = 2654435761;
      static PRIME32_2 = 2246822519;
      static PRIME32_3 = 3266489917;
      static PRIME32_4 = 668265263;
      static PRIME32_5 = 374761393;

      rotl32(x, r) {
        return ((x << r) | (x >>> (32 - r))) >>> 0;
      }

      hash(data) {
        let h32 = (this.seed + XXHash.PRIME32_5) >>> 0;
        h32 = (h32 + 4) >>> 0;
        h32 = (h32 + Math.imul(data >>> 0, XXHash.PRIME32_3)) >>> 0;
        h32 = Math.imul(this.rotl32(h32, 17), XXHash.PRIME32_4) >>> 0;
        h32 ^= h32 >>> 15;
        h32 = Math.imul(h32, XXHash.PRIME32_2) >>> 0;
        h32 ^= h32 >>> 13;
        h32 = Math.imul(h32, XXHash.PRIME32_3) >>> 0;
        h32 ^= h32 >>> 16;
        return h32 >>> 0;
      }

      float(data) {
        return this.hash(data) / 4294967295;
      }

      floatRange(min, max, data) {
        return this.float(data) * (max - min) + min;
      }

      onSphere(data) {
        const phi = this.float(data) * Math.PI * 2;
        const z = this.floatRange(-1, 1, data + 0x10000000);
        const w = Math.sqrt(1 - z * z);
        return { x: Math.cos(phi) * w, y: Math.sin(phi) * w, z: z };
      }

      inSphere(data) {
        const point = this.onSphere(data);
        const r = Math.pow(this.float(data + 0x20000000), 1/3);
        return { x: point.x * r, y: point.y * r, z: point.z * r };
      }
    }

    class CdsTween {
      static step(state, target, speed, dt) {
        const { x, v } = state;
        const n1 = v - (x - target) * (speed * speed * dt);
        const n2 = 1 + speed * dt;
        const nv = n1 / (n2 * n2);
        return { x: x + nv * dt, v: nv };
      }
    }

    class Noise {
      constructor(seed = 0) {
        this.hash = new XXHash(seed);
      }

      fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      lerp(a, b, t) {
        return a + t * (b - a);
      }

      float(p) {
        const i = Math.floor(p);
        const x = p - i;
        const u = this.fade(x);
        const g0 = this.hash.floatRange(-1, 1, i);
        const g1 = this.hash.floatRange(-1, 1, i + 1);
        return this.lerp(g0 * x, g1 * (x - 1), u) * 2;
      }

      fractal(p, octaves = 4) {
        let f = 0, w = 1, scale = 1;
        for (let i = 0; i < octaves; i++) {
          f += w * this.float(p * scale);
          scale *= 2;
          w *= 0.5;
        }
        return f;
      }
    }

    // ============================================
    // Gesture Detection
    // ============================================

    const TIPS = { thumb: 4, index: 8, middle: 12, ring: 16, pinky: 20 };
    const PIPS = { index: 6, middle: 10, ring: 14, pinky: 18 };

    function dist(a, b) {
      return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow((a.z || 0) - (b.z || 0), 2));
    }

    function detectGesture(landmarks) {
      const lm = landmarks;

      // Check pinch first (most specific)
      const pinchDist = dist(lm[4], lm[8]);
      if (pinchDist < 0.06) return { type: 'pinch', pinchDist };

      const extended = {
        index: lm[8].y < lm[6].y,
        middle: lm[12].y < lm[10].y,
        ring: lm[16].y < lm[14].y,
        pinky: lm[20].y < lm[18].y
      };

      if (!extended.index && !extended.middle && !extended.ring && !extended.pinky)
        return { type: 'fist' };

      if (extended.index && extended.middle && extended.ring && extended.pinky)
        return { type: 'open_palm', palmSize: dist(lm[0], lm[12]) };

      if (extended.index && !extended.middle && !extended.ring && !extended.pinky)
        return { type: 'point' };

      if (extended.index && extended.middle && !extended.ring && !extended.pinky)
        return { type: 'peace' };

      return { type: 'unknown' };
    }

    function getHandCenter(landmarks) {
      const wrist = landmarks[0];
      const middleMcp = landmarks[9];
      return {
        x: (wrist.x + middleMcp.x) / 2,
        y: (wrist.y + middleMcp.y) / 2,
        z: (wrist.z + middleMcp.z) / 2
      };
    }

    // ============================================
    // Three.js Scene Setup
    // ============================================

    let scene, camera, renderer, controls;
    let particles, particlePositions, particleVelocities, particleTargets;
    let time = 0;
    let lastTime = performance.now();
    let hash = new XXHash(12345);
    let noise = new Noise(42);

    let settings = {
      tweenSpeed: 8,
      noiseScale: 1,
      particleCount: 3000,
      exploding: false,
      frozen: false,
      rainbowMode: false,
      gestureScale: 1,
      targetRotationX: 0,
      targetRotationY: 0
    };

    let currentGesture = { type: 'none' };
    let gestureBuffer = [];
    const GESTURE_BUFFER_SIZE = 5;

    function smoothGesture(newGesture) {
      gestureBuffer.push(newGesture.type);
      if (gestureBuffer.length > GESTURE_BUFFER_SIZE) gestureBuffer.shift();

      const counts = {};
      for (const g of gestureBuffer) {
        counts[g] = (counts[g] || 0) + 1;
      }

      const majority = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
      if (majority && majority[1] >= 3) {
        return { ...newGesture, type: majority[0] };
      }
      return currentGesture;
    }

    // Gesture icons and names
    const gestureInfo = {
      'none': { icon: 'üëã', name: 'Show your hand!', hint: 'Move hand into camera view' },
      'fist': { icon: '‚úä', name: 'FREEZE!', hint: 'Particles frozen in time' },
      'open_palm': { icon: 'üñêÔ∏è', name: 'ZOOM CONTROL', hint: 'Move closer/further to zoom' },
      'pinch': { icon: 'ü§è', name: 'SCALE MODE', hint: 'Pinch distance controls scale' },
      'point': { icon: 'üëÜ', name: 'EXPLOSION!!!', hint: 'Particles go boom!' },
      'peace': { icon: '‚úåÔ∏è', name: 'RAINBOW MODE', hint: 'Feeling groovy!' },
      'unknown': { icon: 'ü§î', name: 'Unknown gesture', hint: 'Try a different hand shape' }
    };

    function updateGestureUI(gesture) {
      const info = gestureInfo[gesture.type] || gestureInfo['unknown'];
      document.getElementById('gestureIcon').textContent = info.icon;
      document.getElementById('gestureName').textContent = info.name;
      document.getElementById('gestureHint').textContent = info.hint;

      const statusEl = document.querySelector('.gesture-status');
      statusEl.classList.remove('pulse');
      void statusEl.offsetWidth; // Trigger reflow
      statusEl.classList.add('pulse');
    }

    function handleGesture(landmarks) {
      const rawGesture = detectGesture(landmarks);
      const gesture = smoothGesture(rawGesture);
      const handCenter = getHandCenter(landmarks);

      if (gesture.type !== currentGesture.type) {
        currentGesture = gesture;
        updateGestureUI(gesture);

        // Trigger effects
        switch (gesture.type) {
          case 'point':
            triggerExplosion();
            break;
          case 'peace':
            settings.rainbowMode = !settings.rainbowMode;
            document.body.classList.toggle('rainbow-mode', settings.rainbowMode);
            break;
          case 'fist':
            settings.frozen = true;
            break;
          default:
            settings.frozen = false;
        }
      }

      // Continuous effects
      if (gesture.type === 'open_palm' && gesture.palmSize) {
        const targetZoom = 15 + (1 - gesture.palmSize) * 40;
        camera.position.z = THREE.MathUtils.lerp(camera.position.z, targetZoom, 0.1);
      }

      if (gesture.type === 'pinch' && rawGesture.pinchDist !== undefined) {
        settings.gestureScale = 0.5 + rawGesture.pinchDist * 10;
      }

      // Hand position controls rotation
      settings.targetRotationY = (handCenter.x - 0.5) * Math.PI * 2;
      settings.targetRotationX = (handCenter.y - 0.5) * Math.PI;
    }

    function triggerExplosion() {
      settings.exploding = true;

      // Burst effect!
      for (let i = 0; i < particleTargets.length; i++) {
        const dir = hash.onSphere(i + time * 1000);
        const distance = 40 + hash.float(i + 5000) * 30;
        particleTargets[i] = {
          x: dir.x * distance,
          y: dir.y * distance,
          z: dir.z * distance
        };
      }

      setTimeout(() => {
        settings.exploding = false;
      }, 2500);
    }

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x0a0a0f, 0.015);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 35;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = true;

      // Lights
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      const pointLight1 = new THREE.PointLight(0xff6b9d, 3, 100);
      pointLight1.position.set(20, 20, 20);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0x6b9dff, 3, 100);
      pointLight2.position.set(-20, -20, 20);
      scene.add(pointLight2);

      const pointLight3 = new THREE.PointLight(0xc44dff, 2, 100);
      pointLight3.position.set(0, 30, 0);
      scene.add(pointLight3);

      createParticles(settings.particleCount);

      // Central sphere
      const sphereGeo = new THREE.IcosahedronGeometry(4, 5);
      const sphereMat = new THREE.MeshStandardMaterial({
        color: 0xc44dff,
        metalness: 0.8,
        roughness: 0.2,
        wireframe: true
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.name = 'centralSphere';
      scene.add(sphere);

      // Inner glow sphere
      const innerGeo = new THREE.IcosahedronGeometry(3.5, 3);
      const innerMat = new THREE.MeshBasicMaterial({
        color: 0xff6b9d,
        transparent: true,
        opacity: 0.3
      });
      const innerSphere = new THREE.Mesh(innerGeo, innerMat);
      innerSphere.name = 'innerGlow';
      scene.add(innerSphere);

      window.addEventListener('resize', onResize);
      setupUI();
    }

    function createParticles(count) {
      if (particles) {
        scene.remove(particles);
        particles.geometry.dispose();
        particles.material.dispose();
      }

      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);

      particlePositions = [];
      particleVelocities = [];
      particleTargets = [];

      for (let i = 0; i < count; i++) {
        const point = hash.inSphere(i);
        const radius = 18 + hash.float(i + 1000) * 12;

        positions[i * 3] = point.x * radius;
        positions[i * 3 + 1] = point.y * radius;
        positions[i * 3 + 2] = point.z * radius;

        particlePositions.push({
          x: positions[i * 3],
          y: positions[i * 3 + 1],
          z: positions[i * 3 + 2]
        });

        particleVelocities.push({ x: 0, y: 0, z: 0 });
        particleTargets.push({ ...particlePositions[i] });

        // Beautiful gradient colors
        const hue = hash.float(i + 2000);
        const color = new THREE.Color().setHSL(hue * 0.4 + 0.75, 0.9, 0.6);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;

        sizes[i] = 0.08 + hash.float(i + 3000) * 0.15;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 0.12,
        vertexColors: true,
        transparent: true,
        opacity: 0.85,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.1);
      lastTime = now;

      if (!settings.frozen) {
        time += dt;
      }

      document.getElementById('fps').textContent = `FPS: ${Math.round(1 / dt)}`;

      // Rotate scene based on hand position
      scene.rotation.y = THREE.MathUtils.lerp(scene.rotation.y, settings.targetRotationY, 0.05);
      scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, settings.targetRotationX * 0.5, 0.05);

      // Animate central sphere
      const sphere = scene.getObjectByName('centralSphere');
      const innerGlow = scene.getObjectByName('innerGlow');
      if (sphere) {
        sphere.rotation.x = time * 0.3;
        sphere.rotation.y = time * 0.5;

        const pulse = 1 + noise.fractal(time * 0.5, 3) * 0.3;
        const scale = pulse * settings.gestureScale;
        sphere.scale.setScalar(scale);

        if (innerGlow) {
          innerGlow.rotation.x = -time * 0.2;
          innerGlow.rotation.y = -time * 0.3;
          innerGlow.scale.setScalar(scale * 0.9);
        }

        // Rainbow mode color shift
        if (settings.rainbowMode) {
          const hue = (time * 0.2) % 1;
          sphere.material.color.setHSL(hue, 0.8, 0.5);
          if (innerGlow) innerGlow.material.color.setHSL((hue + 0.5) % 1, 0.9, 0.6);
        }
      }

      // Animate particles
      if (particles && !settings.frozen) {
        const positions = particles.geometry.attributes.position.array;
        const colors = particles.geometry.attributes.color.array;

        for (let i = 0; i < particlePositions.length; i++) {
          if (!settings.exploding) {
            const basePos = hash.inSphere(i);
            const radius = (18 + hash.float(i + 1000) * 12) * settings.gestureScale;
            const noiseOffset = noise.fractal(time * 0.3 + i * 0.01, 4) * settings.noiseScale * 4;

            particleTargets[i] = {
              x: basePos.x * (radius + noiseOffset),
              y: basePos.y * (radius + noiseOffset) + Math.sin(time * 1.5 + i * 0.1) * 3,
              z: basePos.z * (radius + noiseOffset)
            };
          }

          const resultX = CdsTween.step(
            { x: particlePositions[i].x, v: particleVelocities[i].x },
            particleTargets[i].x, settings.tweenSpeed, dt
          );
          const resultY = CdsTween.step(
            { x: particlePositions[i].y, v: particleVelocities[i].y },
            particleTargets[i].y, settings.tweenSpeed, dt
          );
          const resultZ = CdsTween.step(
            { x: particlePositions[i].z, v: particleVelocities[i].z },
            particleTargets[i].z, settings.tweenSpeed, dt
          );

          particlePositions[i] = { x: resultX.x, y: resultY.x, z: resultZ.x };
          particleVelocities[i] = { x: resultX.v, y: resultY.v, z: resultZ.v };

          positions[i * 3] = particlePositions[i].x;
          positions[i * 3 + 1] = particlePositions[i].y;
          positions[i * 3 + 2] = particlePositions[i].z;

          // Rainbow mode: shift particle colors
          if (settings.rainbowMode) {
            const hue = ((time * 0.3 + i * 0.001) % 1);
            const color = new THREE.Color().setHSL(hue, 0.9, 0.6);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        if (settings.rainbowMode) {
          particles.geometry.attributes.color.needsUpdate = true;
        }

        particles.rotation.y = time * 0.03;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function setupUI() {
      const tweenSpeedEl = document.getElementById('tweenSpeed');
      tweenSpeedEl.addEventListener('input', (e) => {
        settings.tweenSpeed = parseFloat(e.target.value);
        document.getElementById('tweenSpeedVal').textContent = settings.tweenSpeed;
      });

      const noiseScaleEl = document.getElementById('noiseScale');
      noiseScaleEl.addEventListener('input', (e) => {
        settings.noiseScale = parseFloat(e.target.value);
        document.getElementById('noiseScaleVal').textContent = settings.noiseScale.toFixed(1);
      });

      const particleCountEl = document.getElementById('particleCount');
      particleCountEl.addEventListener('change', (e) => {
        settings.particleCount = parseInt(e.target.value);
        document.getElementById('particleCountVal').textContent = settings.particleCount;
        createParticles(settings.particleCount);
      });

      document.getElementById('randomize').addEventListener('click', () => {
        const newSeed = Math.floor(Math.random() * 100000);
        hash = new XXHash(newSeed);
        noise = new Noise(newSeed + 1);
        createParticles(settings.particleCount);
      });

      document.getElementById('explode').addEventListener('click', triggerExplosion);

      document.getElementById('startCamera').addEventListener('click', initCamera);
      document.getElementById('stopCamera').addEventListener('click', stopCamera);
    }

    // ============================================
    // MediaPipe Hands Setup
    // ============================================

    let handsInstance = null;
    let cameraInstance = null;

    async function initCamera() {
      const btn = document.getElementById('startCamera');
      btn.textContent = '‚è≥ Loading...';
      btn.disabled = true;

      const videoContainer = document.getElementById('video-container');
      videoContainer.classList.remove('camera-off');
      videoContainer.querySelector('div').style.display = 'none';

      const videoElement = document.getElementById('video');
      const canvasElement = document.getElementById('hand-canvas');
      const canvasCtx = canvasElement.getContext('2d');

      try {
        handsInstance = new Hands({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
        });

        handsInstance.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.5
        });

        handsInstance.onResults((results) => {
          canvasElement.width = videoElement.videoWidth || 640;
          canvasElement.height = videoElement.videoHeight || 480;

          canvasCtx.save();
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

          if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            for (const landmarks of results.multiHandLandmarks) {
              drawLandmarks(canvasCtx, landmarks, canvasElement.width, canvasElement.height);
              handleGesture(landmarks);
            }
          } else {
            if (currentGesture.type !== 'none') {
              currentGesture = { type: 'none' };
              updateGestureUI(currentGesture);
              settings.frozen = false;
            }
          }

          canvasCtx.restore();
        });

        cameraInstance = new Camera(videoElement, {
          onFrame: async () => {
            await handsInstance.send({ image: videoElement });
          },
          width: 640,
          height: 480
        });

        await cameraInstance.start();

        btn.textContent = 'üì∑ Camera Active';
        btn.classList.add('active');
        btn.style.display = 'none';
        document.getElementById('stopCamera').style.display = 'inline-block';

        updateGestureUI({ type: 'none' });

      } catch (error) {
        console.error('Camera error:', error);
        btn.textContent = '‚ùå Camera Failed';
        btn.disabled = false;
        videoContainer.classList.add('camera-off');
        videoContainer.querySelector('div').style.display = 'flex';
        videoContainer.querySelector('div').textContent = 'Camera access denied.\nPlease allow camera.';
      }
    }

    function stopCamera() {
      // Stop camera stream
      if (cameraInstance) {
        cameraInstance.stop();
        cameraInstance = null;
      }

      // Close MediaPipe hands
      if (handsInstance) {
        handsInstance.close();
        handsInstance = null;
      }

      // Stop video tracks
      const videoElement = document.getElementById('video');
      if (videoElement.srcObject) {
        videoElement.srcObject.getTracks().forEach(track => track.stop());
        videoElement.srcObject = null;
      }

      // Reset UI
      const startBtn = document.getElementById('startCamera');
      const stopBtn = document.getElementById('stopCamera');
      startBtn.style.display = 'inline-block';
      startBtn.textContent = 'üì∑ Start Camera';
      startBtn.disabled = false;
      startBtn.classList.remove('active');
      stopBtn.style.display = 'none';

      // Reset video container
      const videoContainer = document.getElementById('video-container');
      videoContainer.classList.add('camera-off');
      const msgDiv = videoContainer.querySelector('div');
      msgDiv.style.display = 'flex';
      msgDiv.innerHTML = 'Click "Start Camera"<br>to enable gestures';

      // Clear canvas
      const canvasElement = document.getElementById('hand-canvas');
      const ctx = canvasElement.getContext('2d');
      ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // Reset gesture state
      currentGesture = { type: 'none' };
      gestureBuffer = [];
      settings.frozen = false;
      settings.rainbowMode = false;
      document.body.classList.remove('rainbow-mode');

      updateGestureUI({ type: 'none' });
      document.getElementById('gestureHint').textContent = 'Click "Start Camera" below';
    }

    function drawLandmarks(ctx, landmarks, width, height) {
      // Draw connections
      ctx.strokeStyle = 'rgba(196, 77, 255, 0.6)';
      ctx.lineWidth = 2;

      const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [5, 9], [9, 10], [10, 11], [11, 12],
        [9, 13], [13, 14], [14, 15], [15, 16],
        [13, 17], [17, 18], [18, 19], [19, 20],
        [0, 17]
      ];

      for (const [i, j] of connections) {
        const p1 = landmarks[i];
        const p2 = landmarks[j];
        ctx.beginPath();
        ctx.moveTo(p1.x * width, p1.y * height);
        ctx.lineTo(p2.x * width, p2.y * height);
        ctx.stroke();
      }

      // Draw landmarks
      for (let i = 0; i < landmarks.length; i++) {
        const lm = landmarks[i];
        ctx.fillStyle = i === 4 || i === 8 ? '#ff6b9d' : '#c44dff';
        ctx.beginPath();
        ctx.arc(lm.x * width, lm.y * height, i === 4 || i === 8 ? 6 : 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Start!
    init();
    animate();
  </script>
</body>
</html>
